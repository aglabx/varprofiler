# VarProfiler

A high-performance tool for analyzing k-mer variability across genomes, designed to identify regions of unique sequence complexity. VarProfiler helps researchers understand genomic variation patterns by computing unique k-mer counts in sliding windows across chromosomes.

## Features

- **Fast k-mer counting**: Efficient 2-bit encoding for k-mers up to 31bp
- **Parallel processing**: Multi-threaded chromosome processing with configurable thread count
- **Sliding window analysis**: Configurable window size and step for fine-grained analysis
- **Canonical k-mers**: Automatically handles reverse complements
- **Visualization**: Generate publication-quality plots for each chromosome
- **Memory efficient**: Optimized for large genome analysis
- **Thread control**: Specify number of threads or auto-detect based on CPU cores
- **GFF integration**: Overlay satellite DNA annotations from Tandem Repeat Finder or other sources

## Installation

### Prerequisites

- C++ compiler with C++17 support (g++ or clang++)
- Python 3.7+
- Required Python packages: pandas, matplotlib

### Building from source

```bash
# Clone the repository
git clone https://github.com/yourusername/varprofiler.git
cd varprofiler

# Compile the C++ k-mer profiler
make

# Install Python dependencies
pip install -r requirements.txt

# Or install as a package
pip install .
```

## Usage

### Step 1: Generate k-mer profile

```bash
./kmer_profiler <input.fasta> <output.bed> <kmer_len> <window_size> <step_size> [threads]
```

**Parameters:**
- `input.fasta`: Input genome file in FASTA format
- `output.bed`: Output BED file with k-mer counts
- `kmer_len`: Length of k-mers (1-31, recommended: 23)
- `window_size`: Size of sliding window in bp (e.g., 100000)
- `step_size`: Step size for sliding window in bp (e.g., 25000)
- `threads`: (Optional) Number of threads to use (default: number of CPU cores)

**Examples:**
```bash
# Using default number of threads (auto-detect CPU cores)
./kmer_profiler genome.fa kmer_counts.bed 23 100000 25000

# Using specific number of threads (e.g., 8 threads)
./kmer_profiler genome.fa kmer_counts.bed 23 100000 25000 8
```

### Step 2: Visualize results

```bash
python plot_chromosomes.py <input.bed> -k <kmer_size> [-o output_dir] [-g gff_file]
```

**Parameters:**
- `input.bed`: BED file generated by kmer_profiler
- `-k, --kmer-size`: **Required** - K-mer size used in analysis (must match kmer_profiler)
- `-o, --output_dir`: Directory to save plots (default: kmer_plots)
- `-g, --gff`: Optional GFF file with satellite DNA annotations

**Examples:**
```bash
# Basic visualization (k=23 was used in kmer_profiler)
python plot_chromosomes.py kmer_counts.bed -k 23 -o chromosome_plots

# With satellite DNA annotations overlay (k=31 was used)
python plot_chromosomes.py kmer_counts.bed -k 31 -o chromosome_plots -g satellites.gff
```

## Output Format

### BED file format
The tool outputs a standard BED file with the following columns:
1. Chromosome name
2. Window start position (0-based)
3. Window end position
4. Count of unique k-mers in the window

### Visualization
- Generates one PNG file per chromosome
- High-resolution plots (200 DPI) suitable for publication
- X-axis: Genomic position in megabases (Mb)
- Y-axis: Percentage of unique k-mers in window (0-100%)
- Fixed Y-axis scale (0-105%) for easy comparison across chromosomes
- Orange shading: Satellite DNA regions from GFF annotations (when provided)
- Cyan line/area: K-mer variability profile
- Title includes k-mer size for clarity
- Legend positioned to avoid data overlap

## Algorithm

VarProfiler uses an efficient sliding window approach:

1. **K-mer encoding**: Nucleotides are encoded in 2-bit format (A=00, C=01, G=10, T=11)
2. **Canonical k-mers**: For each k-mer, the lexicographically smaller of the forward and reverse complement is used
3. **Sliding window**: 
   - Initial window: Count all unique k-mers
   - Subsequent windows: Add new k-mers entering the window, remove k-mers leaving
4. **Parallel processing**: Each chromosome is processed in a separate thread

## Performance Considerations

- **Memory usage**: Approximately 1GB per 100Mb of sequence data
- **Speed**: Processes human genome (~3Gb) in approximately 30-60 minutes on a modern multi-core system
- **Optimization tips**:
  - Use larger step sizes for faster processing
  - Adjust window size based on desired resolution
  - K-mer length of 23 provides good balance of specificity and speed

## Applications

- **Genome assembly validation**: Identify regions of low complexity or repetitive sequences
- **Comparative genomics**: Compare k-mer profiles between species or individuals
- **Variant detection**: Identify regions with high sequence variability
- **Primer design**: Find regions with unique k-mers for specific amplification
- **Genome annotation**: Correlate k-mer complexity with functional elements

## Citation

If you use VarProfiler in your research, please cite:
```
Marina Popova, Aleksey Komissarov (2025)
VarProfiler: A tool for k-mer variability profiling across genomes
bioRxiv (manuscript in preparation)
```

## Authors

- Marina Popova
- Aleksey Komissarov
- Claude (AI assistant) - Co-author for code implementation and documentation

## License

MIT License - See LICENSE file for details

## Contributing

Contributions are welcome! Please feel free to submit pull requests or open issues for bugs and feature requests.

## Contact

For questions and support:
- Email: Aleksey Komissarov <ad3002@gmail.com>
- GitHub Issues: https://github.com/aglabx/varprofiler/issues